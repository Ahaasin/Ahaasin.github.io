<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[51单片机中断原理及简单应用]]></title>
    <url>%2F2019%2F09%2F02%2F51%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立键盘与矩阵键盘]]></title>
    <url>%2F2019%2F07%2F19%2Fbutton%2F</url>
    <content type="text"><![CDATA[键盘分为编码键盘和非编码键盘。编码键盘上闭合键识别有专用编码器实现，并产生键编码号和键值。非编码键盘靠软件编程来识别，单片机中多为非编码键盘。 独立按键/矩阵按键独立按键独立按键式直接用I/O口线构成的单个按键电路，其特点是每个按键单独占用一根I/O口线，每个按键的工作不会影响其他I/O口线的状态。独立按键查询时，每个端口默认输出高电平，若按键按下，该端口与GND接通，变为低电平，则我们检测哪一个端口为低电平即可确定哪一个按键被按下。 矩阵按键若按键较多，则独立按键方式需要大量I/O口，这这是我们可以用矩阵键盘方式实现。矩阵键盘有四条I/O口做行线，四条I/O口做列线，每个按键都在行列交点上，如下图矩阵键盘检测时，常用行列扫描法：首先我们向控制列线的低四位输入低电压，向控制行线的高四位输高电平。当有按键被按下，该部分电路被导通，低电平通过按键进入高四位，对应的高四位中的I/O口值不再为1。因此我们检测P1端口值，若高四位不全为1，则说明有按键被按下，通过找出哪一个值不为1，可以确定哪一行的按键被按下。接着，再反过来，向高四位输入低电平，低四位输入高电平，检测出被按下的按键在哪一列，就可以得出被按下的按键的坐标。 按键消抖通常按键所用的开关都是机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上就稳定的接通，在断开时也不会一下子彻底断开，而是在闭合和断开的瞬间伴随了一连串的抖动.稳点时间的长短是由操作人员决定的，正常按下一般都在100ms左右，抖动时长由机械结构决定，一般在10ms左右。为了确保按键检测准确，我们应该在按键稳定时检测，所以我们需要消抖。通常消抖有两种方式，硬件消抖和软件消抖。硬件消抖通过在案件两端并联电容的方式稳定电路软件消抖有很多种方式，我这里用最简单的两次停顿来实现。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;reg52.h&gt;#define key P1typedef unsigned int uint;typedef unsigned char uchar;sbit lsa=P2^2;sbit lsb=P2^3;sbit lsc=P2^4;uint num;uchar code smgduan[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00&#125;;uint line,row;void delay(uint i)&#123; while(i--);&#125;void mtrkey()&#123; char a=0; key=0xf0; //高四位为1，低四位为0 if(key!=0xf0)&#123; delay(1000); //第一次停顿，消除前沿抖动 if(key!=0xf0)&#123; key=0Xf0; switch(key) &#123; //找到按键的行 case(0X70): line=0;break; case(0Xb0): line=1;break; case(0Xd0): line=2;break; case(0Xe0): line=3;break; &#125; key=0x0f; //高四位为0，低四位为1 switch(key) &#123; //找到按键的列 case(0X07): row=0;break; case(0X0b): row=1;break; case(0X0d): row=2;break; case(0X0e): row=3;break; &#125; while((key!=0x0f)) //第二次停顿，消除后沿抖动 &#123; delay(1000); key=0x0f; a++; &#125; &#125; &#125;&#125;void main()&#123; lsa=0;lsb=0;lsc=0; P0=smgduan[0]; while(1)&#123; mtrkey(); num=line*4+row; P0=smgduan[num]; &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数码管显示原理及应用实现]]></title>
    <url>%2F2019%2F07%2F18%2F%E4%B8%80%E4%BA%8C%E4%B8%89%E5%9B%9B%E4%BA%94%2F</url>
    <content type="text"><![CDATA[前面学过了发光二极管的控制，再来讲数码管精容易理解了。 静态/动态数码管显示数码管工作原理简介数码管其实就是几个LED灯组合在一起，所以我们操作数码管也就是操作LED灯。图中七个组成数字的LED加一个小数点LED一共八个LED灯管，如果我们要显示1，那就把b和c点亮，其他类推。 共阴极/共阳极接法这八个LED连接的方法有两种，共阴极和共阳极，下图左边是共阴极，右边是共阳极共阴极中，我们给端口输入高电平，LED就会亮共阳极中，我们输入低电平LED亮。 位选/段选如果我们要显示一个8位数，那么我们要控制8个字段，每个字段有8个LED，我们将选定控制哪一位字段的过程叫做位选，将选定控制某一字段中的哪一个LED的过程叫做段选。 静态显示静态显示特点是每一位数码管都要接到一个八位数据线来保存显示字形码。送入字形码后显示的字形可一直保持。比如假设现在我们要显示一个两位数，那么我们可能需要单片机的P1与P2接口，每个接口的8位分别连接两位数码管的八个LED，以此来控制每一位数字的显示。 动态显示静态显示的缺点显然就是占用单片机太多，如果我们需要显示一个8位数，那就需要64个引脚。动态显示将所有数码管段选线并联在一起，有位选线控制是哪一位数码管有效。选亮数码管采用动态扫描显示，轮流向各数码管发送字形码，利用数码管的余辉喝人眼的视觉暂留作用，使人感觉各位数码管在同时显示。 本实验板的电路图这就是HC6800—ES V2.0的数码管的电路。左端的138译码器用来位选，其左上角有ABC三个端口，三端口分别接在P22P23P24引脚上，数值分别是0或1，组成一个三位二进制数，其数值介于0~7之间，用来表示8位数码管。右图左下角是一个573锁存器，在这里的功能是控制某一位上的八个LED灯管，用P0的八位针脚来表示。这样，我们控制单片机的11个引脚，实现了对64个LED的控制。 关于锁存器这块实验板上的锁存器功能体现的不明显，我们以天翔电子的TX-1C为例。那块板子上的段选和位选都是由573锁存器来控制，每个锁存器都有一个锁存端，就是上图中的右图左下角LE端口。当LE打开，锁存器内部导通，上图可以看出锁存器左端接一个个引脚，右端接段选线控制LED，内部导通时引脚输入什么数，右端就会输出 什么数，左端的数会传导到右端。当LE关闭时，内部不导通，左端将保持原来的值不变。 在TX-1C中，我们用两个引脚控制两个锁存器的锁存端，两个锁存器再共用8个引脚做位输入，一共10个引脚完成控制。 位选时，位选锁存器打开，8个引脚输入相应数值（11111110表示控制第一个数码管，11111101表示控制第二个，类推），再关闭锁存器，保存这一数值。接着打开段选的锁存端，输入相应的字形码以控制某一个数码管显示什么数字。 实验程序1234567891011121314151617181920212223242526272829#include&lt;reg52.h&gt; typedef unsigned char uchar;typedef unsigned int uint;sbit lsa=P2^2;sbit lsb=P2^3; sbit lsc=P2^4;uint code smgwei[9][3]=&#123;0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1&#125;; //位选uchar code smgduan[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00&#125;; //0,1,2....的字形码void delay(uint i)&#123; while(i--);&#125;void smg(uint i,uint j)&#123; lsa=smgwei[i][2];lsb=smgwei[i][1];lsc=smgwei[i][0]; //位选赋值 P0=smgduan[j]; //断选 delay(100); //因为要以一定的频率刷新，所以需要延时一定时间 P0=0x00; //归零一下，否则在下一位数码管会出现残影&#125;void main()&#123; uint i; while(1)&#123; for(i=0;i&lt;8;i++)&#123; smg(i,i); //第一位到第八位分别显示0~7 &#125; &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蜂鸣器的原理及控制]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%2F</url>
    <content type="text"><![CDATA[蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于计算机、打印机、复印机、报警器、电子玩具、汽车电子设备、电话机、定时器等电子产品中作发声器件。蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。蜂鸣器在电路中用字母“H”或“HA”（旧标准用“FM”、“ZZG”、“LB”、“JD”等）表示。 蜂鸣器的使用蜂鸣器工作原理有源/无源蜂鸣器先给个百度百科链接有源蜂鸣器，也叫电磁式蜂鸣器，内部有电磁振荡器，接通直流电源后周期性振动发声，无源蜂鸣器，也叫压电式蜂鸣器，内部没有电磁振荡器，需要接带有一定波形的电流，改变波形可以改变发出的声音的音调等等。这块实验板上是一个无源蜂鸣器 实验板上的电路单片机的引脚无法直接驱动蜂鸣器，需要经过信号放大才能驱动。在这块实验板中，蜂鸣器是无源的，用的放大器是ULN2003. 在有源蜂鸣器中，可以直接用一个三极管放大信号，实际上ULN2003内部也是NPN三极管。 程序控制蜂鸣器找引脚接口在上面的电路图中可以看到，蜂鸣器端口标号是 BZ 由于蜂鸣器是接在ULN2003上的，所以在ULN2003电路图上也有一个BZ，与之对应的是端口P15，那么我们控制的就是P15端口。 写程序上面说到了，这块板子上是一个无源蜂鸣器，需要不断变换端口输出值来模拟脉冲信号，引脚参数beep值为1的时候高电平，为0的时候低电平，从1到0变换一次表示一次振动，连续振动就能发声。 #include&lt;reg52.h&gt; typedef unsigned char uchar; typedef unsigned int uint; sbit beep=P1^5; //控制蜂鸣器的引脚为P15 void delay(uint i){ while(i--); } void main(){ while(1){ beep=~beep; delay(80); //每80个单位时间振动一下，周期160单位时间 } }]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点亮发光二极管]]></title>
    <url>%2F2019%2F07%2F10%2F51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[点亮LED，LED闪烁点亮LED第一个内容是关于LED灯的，首先就是如何让他亮。那么我们先看一下这块实验版的LED模块的电路图： （其实图上是有一点错误的，图中的二极管标号从上到下依次是D1 D2 D3….） 图中可以看出，当左端是低电位的时候，二极管导通，LED灯亮。在单片机中，0表示低电位，1表示高电位，所以我们只需要将端口参数置零，LED就会亮。端口参数志玲，端口又是什么呢？我们还是看电路图。我们可以看到，这图里的8个二极管左侧有棕红色的标号P20 P21 P22……这些表示的是处理器的引脚，89C52一共有4组共32个引脚，我们编程控制的就是这些引脚。所以我们将端口置零就是将引脚参数设置为0。在程序中，我们一般这么写： 123456789101112#include&lt;reg52.h&gt; //51单片机的头文件sbit led1=P2^0; //sbit是定义了一个位（一个字节八个位的那个位），和int，float这些差不多sbit led2=P2^1; //这两句话的意思是，定义两个位，名字叫led1，led2，led1存的是引脚p20的值，led2是p21void main()&#123; while(1) //一个死循环，程序才会一直执行下去 &#123; led1=0; //p20引脚参数为0，输出低电平 led2=0; &#125;&#125; 写好后，和C语言类似，我们得先调试，按F7或者点这个调试没有错误以后，我们要将程序拷录进单片机，就要用到 ，具体步骤如下： 上次忘了写一个步骤，就是生成.hex文件，这个在keil里面是默认不生成的，但是拷录时必须是.hex格式的文件。生成步骤如下： 拷录好后，我们再打开单片机，就是这个程序。 LED闪烁到此，我们已经解决了灯亮的问题，如何让灯会闪呢？我们只需要加一个循环，让端口参数从1到0周期变换，就像下面： 123456789101112131415161718#include&lt;reg52.h&gt;typedef unsigned char uc;typedef unsigned int ui;sbit led=P2^0;void delay(ui i)&#123; while(i--);&#125;void main()&#123; while(1)&#123; led=0; delay(10000); led=1; delay(10000); &#125;&#125; 跑马灯只让一个灯闪那不够土，为了够土，我们要让他循环闪。那么最容易想到的就是依次给端口赋值，这样未免太麻烦，我们可以直接这么写 写法1123456789101112131415161718#include&lt;reg52.h&gt;typedef unsigned char uchar;typedef unsigned int uint;void delay(uint i)&#123; //延时函数 while(i--); &#125; void main()&#123; uchar a; a=0x01; while(1)&#123; P2=a; delay(10000); a=a&lt;&lt;1; //位运算，实现循环 f(a==0x00) //防止溢出 a=0x01; &#125; &#125; 0x01是一个十六进制数，表示的是0000 0001，也就是端口P2的值依次为00000001。&lt;&lt; 左移一位后变成了0000 0010。 写法2我们也可以换一种写法，将端口值变为11111110就是0xfe然后循环位变换，这里引进一个函数，_crol_（char，int），效果看程序和结果 1234567891011121314151617#include&lt;reg52.h&gt;#include&lt;intrins.h&gt;typedef unsigned char uchar;typedef unsigned int uint;void delay(uint i)&#123; while(i--);&#125;void main()&#123; uchar a; a=0xfe; //表示1111 1110 while(1)&#123; P2=a; delay(10000); a=_crol_(a,1); //循环位移，函数的第二个参数表示移多少位，这里第一次执行后a变成了1111 1101 &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP，洛谷P040]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%A0%91%E5%BD%A2DP%EF%BC%8C%E6%B4%9B%E8%B0%B7P040%2F</url>
    <content type="text"><![CDATA[洛谷P1040/树形DP/区间DP题目描述设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；（1）tree的最高加分（2）tree的前序遍历 输入格式：第1行：一个整数n（n＜30），为节点个数。第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。 输出格式：第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。第2行：n个用空格隔开的整数，为该树的前序遍历。输入输出样例 输入样例：55 7 1 2 10 输出样例：1453 1 2 4 5 题目链接：洛谷P1040 题目解读中序遍历为1，2，3，…..，那么当k为根节点时，编号小于k的节点必然在左子树上，编号大于k的节点必然在右子树上。对于一个节点，当他的值最大时，必然是他左右节点乘积最大时，那么有状态转移方程 f[i][j]=max(f[i][k-1]f[k+1][j])+point[k]，i&lt;=k&lt;=j 遍历每一个节点当作根结点时的情况，再向左子树右子树分别遍历，当f[i][j]有值时直接返回值，没有值时找到最大值并返回（可能不是很好理解，具体见代码）。 同时，每次f[i][j]取得max时，记录root[i][j]，也就是i节点和j节点的根节点，方便输出前序遍历。 更新一个区间DP的写法，思路都是一样的，区间DP先找出两个节点组成树的所有情况，再根据上面的状态转移方程，找出3个节点的情况，最后一步步推出所有节点的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long ans,f[31][31];int n,root[31][31],cot=1;long long dfs(int left,int right) //深搜，树形DP&#123; long long k; if(left&gt;right) return 1; if(f[left][right]==-1) &#123; for(int i=left;i&lt;=right;i++) &#123; k=dfs(left,i-1)*dfs(i+1,right)+f[i][i]; if(k&gt;f[left][right]) &#123; f[left][right]=k; root[left][right]=i; &#125; &#125; &#125; return f[left][right];&#125;void pretra(int left,int right) //输出前序遍历&#123; if(left&gt;right) return; if(cot++!=1) cout&lt;&lt;' '; cout&lt;&lt;root[left][right]; pretra(left,root[left][right]-1); pretra(root[left][right]+1,right); return ;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; f[i][j]=-1; root[i][i]=i; &#125; &#125; for(int i=1;i&lt;=n;i++) cin&gt;&gt;f[i][i]; cout&lt;&lt;dfs(1,n)&lt;&lt;endl; pretra(1,n); return 0;&#125; 区间DP的主要代码： 1234567891011for(int len=2;len&lt;=n;len++)&#123; //最外层枚举长度 for(int i=1;i&lt;=n-len+1;i++)&#123; //第二层，枚举每一个长度为len的片段 int j=i+len-1; for(int k=i;k&lt;=j;k++)&#123; //枚举某一个片段下每个节点当做更节点的情况 if(f[i][j]&lt;f[i][k-1]*f[k+1][j]+f[k][k])&#123; f[i][j]=f[i][k-1]*f[k+1][j]+f[k][k]; root[i][j]=k; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>区间DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何/凸包/安德鲁]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%B0%8F%E5%B8%83%E5%B0%94%E4%B9%94%E4%BA%9A%E2%80%9D%2F</url>
    <content type="text"><![CDATA[计算几何/凸包/安德鲁算法先说一下凸包是啥抽象解释：在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造（来自百度百科）； 简单理解：对于一个平面空间上的点集，其中的一些点总可以构成一个凸多边形，这个多边形（包括边界）包含了改点集内所有的点，这个凸多边形就是凸包。如图：在计算几何领域，有很多个求凸包的方法，这里主要讲比较容易掌握安德鲁算法（Andrew’s Algorithm)（因为我菜…) 算法基本思路1.将给定的集合的点按X坐标升序排序，X相同则按Y升序排序； 2.创建凸包上部：将排序后的点按从小到大顺序加入凸包A，若新加入的点使凸包A不再是凸多边形，则逆序删除之前加入的点，直到重新变成凸多边形；3.创建凸包下部：将排序后的点按从大到小顺序加入凸包B，若新加入的点使凸包B不再是凸多边形，则逆序删除之前加入的点，直到重新变成凸多边形； （显然排序后的第一个点和最后一个点必定在凸包上）注：若a X b &gt; 0，表示a在b的顺时针方向上若a X b &lt; 0，表示a在b的逆时针方向上若a X b == 0，表示a与b共线，但不确定方向是否相同 下面用图解说明一下安德鲁算法: 第一步，将最开始的两个点加入凸包。第二步，按照顺序选定点Si（不入凸包），若Si在凸包的倒数第二个点和倒数第一个点构成的向量的逆时针方向，就从凸包中删除倒数第一个点，循环此过程，直至Si在该向量顺时针方向，此时将Si入凸包。 点2在点0指向点1的向量的顺时针方向，点2入凸包； 点3在点1指向点2的向量的逆时针方向，点2从凸包中删除，此时点3在点0指向点1的向量的顺时针方向，入凸包；点4在点1指向点3的向量的顺时针方向，点4入凸包；点5在点3指向点4的向量的逆时针方向，点4从凸包中删除，此时点5在点1指向点3的向量的顺时针方向，入凸包；点6在点3指向点5的向量的逆时针方向，点5从凸包中删除，此时点6还在点1指向点3的向量的逆时针方向，点3从凸包中删除，此时点6在点0指向点1的向量的顺时针方向，入凸包；最后点7在点1到点6的向量的顺时针方向，点7入凸包 凸包上部构建完成 下部同理 最后两部分相连，即可得凸包。 代码&amp;例题破oj3348 Cows题目大意：给出一些树的坐标，一这些树为顶点可以围成一片牧场，牧场中每50个单位可以放一头牛，问最多可以放多少牛。求最大牧场面积，就是求凸包面积。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt; using namespace std;struct point&#123; int x,y; point()&#123;&#125; point(int xx,int yy)&#123; x=xx; y=yy; &#125; point operator - (const point a)const&#123; return point(x-a.x,y-a.y); &#125;&#125;p[11000],ch[11000]; //储存原来的点集和凸包序列bool cmp(point a,point b)&#123; //点排序 if(a.x==b.x) return a.y&lt;b.y; return a.x&lt;b.x; &#125;double chachen(point a, point b) &#123; //返回叉乘的膜 return a.x*b.y-a.y*b.x;&#125;int tubao(point *p,int n, point *ch)&#123; //构造凸包 sort(p,p+n,cmp); int m=0; for (int i=0;i&lt;n;i++)&#123; //上部 while (m&gt;1&amp;&amp;chachen(ch[m-1]-ch[m-2],p[i]-ch[m -2])&lt;=0) //删除不凸的点 m--; ch[m++]=p[i]; &#125; int k=m; for (int i=n-2;i&gt;=0;i--)&#123; //下部 while (m&gt;k&amp;&amp;chachen(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) //删除不凸的点 m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m; //返回凸包中元素个数&#125;int main(void)&#123; int n,m,ans; double area = 0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y; m=tubao(p,n,ch); for(int i=0;i&lt;m;i++)&#123; area+=ch[i].x*ch[i+1%m].y-ch[i+1%m].x*ch[i].y;//计算面积 &#125; if(area&lt;=0) area=-area; ans=area/100; //计算面积要除2，再加上计算结果要除50，总共除100 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>安德鲁算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Theme-Sakura]]></title>
    <url>%2F2018%2F12%2F12%2FHexo-Theme-Sakura%2F</url>
    <content type="text"><![CDATA[hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 12345678# Sitetitle: 你的站点名subtitle:description: 站点简介keywords:author: 作者名language: zh-cntimezone: 部署 123456deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） 1234567backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# site name# 站点名 【改】prefixName: さくら荘そのsiteName: hojun# favicon and site master avatar# 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】favicon: /images/favicon.icoavatar: /img/custom/avatar.jpg# 站点url 【改】url: https://sakura.hojun.cn# 站点介绍（或者说是个人签名）【改】description: Live your life with passion! With some drive!# 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpgcdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6# 开启pjax 【选】pjax: 1# 站点首页的公告信息 【改】notice: hexo-Sakura主题已经开源，目前正在开发中...# 懒加载的加载中图片 【选】lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg# 站点菜单配置 【选】menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125;# Home page sort type: -1: newer first，1: older first. 【非】homePageSortType: -1# Home page article shown number) 【非】homeArticleShown: 10# 背景图片 【选】bgn: 8# startdash面板 url, title, desc img 【改】startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125;# your site build time or founded date# 你的站点建立日期 【改】siteBuildingTime: 07/17/2018# 社交按钮(social) url, img PC端配置 【改】social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125;# 社交按钮(msocial) url, img 移动端配置 【改】msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125;# 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg# 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true# Valine评论配置【改】valine: truev_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHszv_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 12345678910111213141516171819#category# 按分类名创建技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg#tag# 标签名即是标题悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： 123456789---title: commentdate: 2018-12-20 23:13:48keywords: 留言板description: comments: true# 在这里配置单页面头部图片，自定义替换哦~photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg--- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） 123456789101112131415161718192021222324252627282930---layout: bangumititle: bangumicomments: falsedate: 2019-02-10 21:32:48keywords:description:bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。--- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） 1234567891011121314151617181920212223242526272829303132333435363738394041424344---layout: linkstitle: links# 创建日期，可以改下date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改keywords: 友人帐 description: # true/false 开启/关闭评论comments: true # 页面头部图片，自定义修改photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像--- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： 1&#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： 1&#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
</search>
