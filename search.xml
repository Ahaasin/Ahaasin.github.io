<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python学习计划（1）]]></title>
    <url>%2F2020%2F02%2F18%2Fpython%E5%9F%BA%E7%A1%80%E2%80%9C%2F</url>
    <content type="text"><![CDATA[Python基础对一些基本的语法做一个记录，很多都和C语言的一样，看一遍大概就能记住了。 变量类型整型:Python3.0以上就不再区分int和long了，整型只有int一种；浮点型字符串型布尔型复数型：形如3+1j(j前必须有数字)。 注释单行注释以‘#’开头，多行注释以‘“””’开头； 运算符这里只列出少数Python中我不熟悉的运算符： 运算符 描述 [] [:] 下标，切片 ** 指数 / // 除，整除 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 输入输出函数是input和print 1234567a=int(input('a=')) #input输入,int()表示输入的是整型b=int(input('b='))print('%d+%d=%d'%(a,b,a+b)) #中间的%作用类似于C语言中输出时的&amp;flag0 = 1 == 1print('flag0 =', flag0) # flag0 = True 几个练习输入圆的半径计算周长与面积1234567import math #某种意义上的头文件，import是导入的意思，具体后面再说r=float(input('请输入圆的半径：'))perimeter=2*math.pi*rarea=math.pi*r*rprint('周长=%.2f'%perimeter)print('面积=%.2f'%area) 判断闰年123year=int(input('输入年份：'))is_leap=(year%4==0 andyear%100!=0) or year%400==0 #与或非不能用&amp;&amp;等print(is_leap) 分支结构 if(条件)结构 变成 if 条件 :结构; Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，如果要嵌套，再按规矩缩进即可； else if用elif代替。 循环结构for-in循环1234567"""用for循环实现1~100求和"""sum = 0for x in range(101): sum += xprint(sum) 需要说明的是上面代码中的range(101)可以用来构造一个从0到100的取值范围，这样就可以构造出一个整数的序列并用于循环中，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中2是步长，即数值序列的增量。 123456789"""用for循环实现1~100之间的偶数求和"""sum = 0for x in range(2, 101, 2): sum += xprint(sum) while循环与C语言的while循环相比，条件处不需要(),改用:,不用{}，改用缩进表示并列，与if结构类似]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2020%2F01%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[LCD1602使用]]></title>
    <url>%2F2019%2F10%2F19%2FLCD1602%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[LCD全称Liquid Crystal Display，中文名液晶显示器。要实现机器与人的交互，那么就要给人一个直观的输出显示，数码管的丰富性过低，于是便要学习LCD显示器 LCD1602液晶显示屏的使用工作原理LCD1602专门用来显示字母、数字、符号，由两行，每行16个57或510的点阵自字符位组成，每个字符位可以显示一个字符。显示器内置128个ASCII码字符库，只有并行接口。 接口信号说明1602有16个接口控制，接口功能如下图 基本时序操作读状态：输入： RS=L,R/W=H,E=H;读数据： 输入：RS=H,R/W=H,E=H;写指令： 输入：RS=L,R/W=L,D0D7=指令码，E=高脉冲；写数据： 输入：RS=H,R/W=L,D0D7=数据，E=高脉冲. DDRAM1602显示器基于HD44780芯片，其内置了DDRAM、CGRAM和CGROM。DDRAM相当于RAM，用来寄存待现显示的字符代码，共80个字节，地址和屏幕的对应关系如下： 当我们想要在第二行第一列显示“A“，只要在40H地址输入”A”的字形码就行了。显示器只有16列，那么第一行10H和第二行50H之后的地址上的数据，需要通过移屏指令将他们移入。 状态字说明 原则上每次对单片机进行读写操作之前，都必须先进行读写检测，确保STA7=0，实际上，单片机操作速度慢于液晶控制器反应速度，因此可不进行检测，只进行短暂延时即可。 指令操作清屏指令 功能：1.将DDRAM全部填入“空白”ASCII码20H；2.光标归位；3.将地址计数器值设置为0。进入模式设置指令功能：进入一位数据后光标移动方向，字符是否移动。|I/D：| 0 =光标左移 | 1=光标右移|| – | – | – |S： | 0=显示屏不移动 | 1=显示屏整体右移显示开关控制指令 功能：控制显示器开关、光标是否显示及光标是否闪烁|位名|0|1|–|–|–|D|显示功能关|显示功能开C|无光标|有光标B|光标闪烁|不闪烁功能设定指令 功能：设定数据总线位数、显示的行数及字形。|位名|0|1|–|–|–|DL|数据总线4位|8位N|显示一行|两行F|每字符57点阵|510点阵 写操作时序 通过RS确定写数据还是命令 R/W端设置为写模式 将数据或命令送达数据总线 给E一个高脉冲，将数据送入液晶显示器图中各个时序的延时因厂家不同而不同，大多很小，但为了运行稳定，最好短暂延时。 单片机接口 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;reg52.h&gt;typedef unsigned int uint;typedef unsigned char uchar;sbit rs=P2^6;sbit wr=P2^5;sbit e=P2^7;void delay(uint a)&#123; uint i=100; while(a--)&#123; while(i--); &#125;&#125;void w_com(uchar com)&#123; //写指令 rs=0; wr=0; P0=com; delay(1); e=1; //使能推动 delay(1); e=0;&#125;void w_dat(uchar dat)&#123; //写数据 rs=1; wr=0; P0=dat; delay(1); e=1; delay(1); e=0;&#125;void init()&#123; //初始化 w_com(0x0c); //各种指令，详见上 w_com(0x38); w_com(0x06); w_com(0x01); delay(5);&#125;void pos_w(uchar x,uchar y,uchar a)&#123; //显示字符‘a’在x行y列 if(y)&#123; w_com(0x80+x); &#125; else &#123; w_com(0xc0+x); &#125; w_dat(a);&#125;int main()&#123; init(); pos_w(0,1,'a'); while(1);&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWM波形输出]]></title>
    <url>%2F2019%2F10%2F11%2FPWMb%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[PWM波输出PWM（Pulse Width Modulation)控制——脉冲宽度调制技术。通过对一系列脉冲的宽度进行调制，来等效的获得所需的波形（包括形状和赋值），对模拟信号进行数字编码。 基本原理占空比：输出波形中，高电平保持的时间与时钟周期之比。例如，一个单片机频率1000Hz，时钟周期就是1ms，如果高电平出现时间是500毫秒，那么占空比就是50%分辨率：最小能达到的占空比，如8位的PWM，理论的分辨率就是1:255(单斜率)， 16位的的PWM理论就是1:65535(单斜率)。单斜率/双斜率：假设一个PWM从0计数到80，之后又从0计数到80……. 这个就是单斜率。 假设一个PWM从0计数到80，之后是从80计数到0……. 这个就是双斜率。理论基础：冲量相等而形状不同的窄脉冲加在具有惯性的环节上时，其效果基本相同。冲量指窄脉冲的面积。效果基本相同，是指环节的输出响应波形基本相同。低频段非常接近，仅在高频段略有差异。面积等效原理： 分别将如图1所示的电压窄脉冲加在一阶惯性环节（R-L电路）上，如图2a所示。其输出电流i(t)对不同窄脉冲时的响应波形如图2b所示。从波形可以看出，在i(t)的上升段，i(t)的形状也略有不同，但其下降段则几乎完全相同。脉冲越窄，各i(t)响应波形的差异也越小。如果周期性地施加上述脉冲，则响应i(t)也是周期性的。用傅里叶级数分解后将可看出，各i(t)在低频段的特性将非常接近，仅在高频段有所不同。 用一系列等幅不等宽的脉冲来代替一个正弦半波，正弦半波N等分，看成N个相连的脉冲序列，宽度相等，但幅值不等；用矩形脉冲代替，等幅，不等宽，中点重合，面积（冲量）相等，宽度按正弦规律变化。SPWM波形——脉冲宽度按正弦规律变化而和正弦波等效的PWM波形。 如何实现PWM波形输出1.可以直接通过芯片内部模块输出PWM信号，前提是这个I/O口要有集成模块，只需要简单几步操作即可，这种自带有PWM输出的功能模块在程序设计更简便，同时数据更精确。如下图，一般的IC口都会标明这个是否是PWM口； 2.如果内部没有PWM功能模块，或者功能要求不是很高的话，可以通过I/O口配置一些参数实现PWM信号输出。这里用第二种方式。假设我们要频率为f的PWM波形，那么算出f对应的周期t，然后用定时器定时时间间隔为t/n，n是一个整数，如果需要占空比为 p%，那么就在中断子程序内设置，当计数到p*t/n以上次数时，输出高电平，反之低电平。假设我们需要1000Hz的波形，那么周期就是1ms，我们可以用定时器设置时间间隔为0.01ms，中断100次就是1ms。在中断子程序内设置一个变量count用以计数，当count&gt;=100时清零，当count&gt;p时输出高电平。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;reg52.h&gt;#define uchar unsigned char#define uint unsigned intuint num;sbit PWM=P2^0;void pre()&#123; //定时器初始化 EA=1; ET0=1; TR0=1; TMOD=0x01; TH0=0xff; TL0=0xF7;&#125;int main()&#123; pre(); while(1)&#123; if(num&gt;=100)&#123; //控制周期 num=0; &#125; if(num&gt;50)&#123; //控制占空比为50% PWM=1; &#125; else &#123; PWM=0; &#125; &#125;&#125;void time0() interrupt 1&#123; //定时器 TH0=0xff; TL0=0xF7; num++;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器/计数器的原理及使用]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%AE%9A%E6%97%B6%E5%99%A8-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[定时器计数器也可以简称定时器，是单片机内与CPU独立的一个硬件，是单片机的重点内容之一 CPU时序 振荡周期：为单片机提供实时信号震荡源的周期（晶振周期或外加震荡周期）； 状态周期：两个振荡周期； 机器周期：六个机器周期； 指令周期：完成一条指令的全部时间，以机器周期为单位。 当外接晶振频率为12M时：振荡周期：1/12M=1/12微秒状态周期：1/6us机器周期：1us指令周期：1~4us 51单片机定时器结构定时器计数器实质是加1计数器（16位），由高八位和低8位两个寄存器组成，工作时先向低8位累加，加满后再向高8位累加，高8位溢出后发出中断信号。TMOD是工作方式寄存器，确定工作方式与功能，TCON是控制寄存器，前面已经讲过。 TMOD寄存器TMOD是定时器计数器的工作方式寄存器，低四位控制定时器T0，高四位控制定时器T1。 GATE：门控位，GATE=0，定时器计数器的启动与停止仅受TCON寄存器中的TR0/TR1，GATE=1时，受TR0/TR1与外部中断引脚（INT0/INT1）上的电平共同控制‘’ C/T：定时器模式和计数模式选择位，C/T=1为计数器模式，C/T=0为定时器模式； M1M0：工作方式选择位，每个定时器都有四种工作方式，如下表： M1M0 工作方式 00 方式0，为13位定时器计数器 01 方式1，16位定时器计数器 10 方式2,8位初值自动重装的8位定时器计数器 11 方式3，仅适用于T0，分成两个8位计数器，T1停止计数 定时器计数器工作方式在这里我们以方式1为例。定时器0方式1的逻辑结构如图： 当GATE=0，TR0=1，低8位TL0在机器周期的作用下开始加1计数，当TL0计满后，向TH0进位，直到TH0也满，此事计数器溢出，TF0置1，向CPU请求中断。那么如何让定时器定时自己想要的时间呢？定时器每执行一次+1需要一个机器周期，即12个振荡周期，在时钟频率为12MHz的单片机中，1个机器周期为1us，那么计满计数器需要2^16个机器周期，大约65.5ms。如果我们要定时50ms，就要给TL0TH0装一个初值，在这个初值上加50000个数后，定时器计数器溢出，就是50ms中断一次。当需要1s中断一次时，我们只需要编写程序，使定时器产生20个50ms的中断后执行中断程序。如何计算初值呢？当我们要定时50ms，那初值应该是2^16-50000=15536。15536/256=60装入高8位，15536%256=176装入低8位。 定时器程序编写使用定时器前需对寄存器进行初始化： 对TMOD赋值，确定T0/T1工作方式 计算初值，填入TH0/TL0； 对IE0赋值，开放中断； 使TR0/TR1置位，启动计数。 接着我们编写程序，目的是使第一个发光二极管以2s为周期闪烁。 123456789101112131415161718192021222324252627#include&lt;reg52.h&gt;#define uchar unsigned char#define uint unsigned intsbit led=P2^0;uint num=0;void main()&#123; EA=1; ET0=1; led=0; TR0=1; TMOD=0x01; TH0=0xFC; TL0=0x18; while(1);&#125;void time0() interrupt 1&#123; TH0=0xFC; TL0=0x18; num++; if(num==1000)&#123; num=0; led=~led; &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo下NexT7.X主题的美化及其他设置]]></title>
    <url>%2F2019%2F09%2F05%2Fhexo%E4%B8%8BnexT7-X%E4%B8%BB%E9%A2%98%E7%9A%84%E7%BE%8E%E5%8C%96%E5%8F%8A%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近把博客主题换成了next，NexT主题现在已经更新到了7.X版本，许多设置都与以前不同了。本菜鸡把碰到的各种问题及其在网上找到的解决方案汇总一下。 主题设置打开主题配置页面，搜索scheme，会出现主题的相关选项，有mist，muse，pieces，Gemini四个选项，要选定的话直接取消注释就好了。 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 设置菜单的标签页及分类等在主题配置界面搜索menu，会出现menu seting，需要某一项就取消哪一项的注释，或者自己添加。 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 同时需要新建相应的页面，例如取消了tags的注释，就需要执行以下代码 1hexo new page tags 然后打开新生成的.md文件，添加页面类型字段，其值设置为tags 12345---title: tagsdate: 2019-09-03 13:09:42type: "tags" # 新生成的文件没有这一句--- 在 about: /about/ || user 中，||后面的user表示的是图标，你可以在http://fontawesome.dashgame.com/ 网站挑选自己喜欢的图标，将代码替换上去。 添加侧边栏社交按钮在主题配置文件中搜索social links，会出现相关的配置，如下图 123456789101112131415161718social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope Weibo: https://weibo.com/5534286284 || weibo bilibili: https://space.bilibili.com/13167229 || tv #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vkhttps://www.zhihu.com/people/tu-tao-33 #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false 想要添加某个社交账号，可以将前面的注释去掉，再将链接改成自己的社交帐号主页的链接。你也可以自己添加其他的网站。||后面同样是图标。 添加头像及旋转设置将你所想设置成头像的图片放置在/themes/next/source/images文件夹下，在主题配置文件中搜索avatar，进行如下配置 12345678910# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.png # avatar.png改成你的头像文件的文件名 # If true, the avatar would be dispalyed in circle. rounded: true # 鼠标放在头像上，头像会旋转 # If true, the avatar would be rotated with the cursor. rotated: true # 头像设置成圆形，否则是矩形 动态背景设置在主题配置界面搜索canvas，定位到如下代码，为三种动态背景。将自己需要的样式相关参数设置为true即可。但由于新版本下相关的文件并没有默认下载，故需要先下载文件，具体步骤为在theme/source/lib/位置执行控制台指令： 1git clone https://github.com/theme-next/theme-next-three source/lib/three 随后，在主题文件中将相关的条件设置为true。在这里我用的是three。 12345678910111213141516171819202122232425262728# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-threethree: enable: true delay: false # Set true to further delay loading three_waves: true canvas_lines: true canvas_sphere: true# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nest# For more information: https://github.com/hustcc/canvas-nest.jscanvas_nest: enable: false onmobile: true # Display on mobile or not color: "0,0,255" # RGB values, use `,` to separate opacity: 0.5 # The opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # The number of lines# Canvas-ribbon# Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon# For more information: https://github.com/zproo/canvas-ribboncanvas_ribbon: enable: false size: 300 # The width of the ribbon alpha: 0.6 # The transparency of the ribbon zIndex: -1 # The display level of the ribbon 全站字体统计首先在根目录下执行指令 1npm install hexo-wordcount --save 然后找到/themes/next/layout/_partials/文件夹里的footer.swig文件，在底部添加代码 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加live看板娘下载看板娘项目，解压到themes/next/source/，修改解压文件中的autoload.js，如下 123const live2d_path = "https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/";改为const live2d_path = "/live2d-widget/"; 在/themes/next/layout/_layout.swing中添加如下内容： 1&lt;script src="/live2d-widget/autoload.js"&gt;&lt;/script&gt; 在主题配置文件中添加如下内容 12live2d: enable: true 设置加载动画在主题配置文件中搜索pace,会定位在如下位置： 123456pace: enable: true # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: center-atom 将enable参数设置为true，将theme设置为自己想要的动画类型，可选项就是theme在上面两行。新版本下可能修改后依然不生效，同动态背景的设置一样，需要先下载相关的文件，即在theme/source/lib/位置执行控制台指令： 1git clone https://github.com/theme-next/theme-next-pace source/lib/pace 文章折叠在主题配置文件中搜素auto_excerpt,将enable设置成true，length数值表示的是不折叠的字段长度。 123auto_excerpt: enable: true length: 10 添加搜索功能首先要安装搜索插件 1npm install hexo-generator-searchdb --save 在根目录下的站点配置文件中添加以下内容 12345search: path: search.xml field: post format: html limit: 10000 在主题配置文件中启用搜索功能,定位到local search，将enable改为true。 12345678910111213# Local Search# Dependencies: https://github.com/wzpan/hexo-generator-searchlocal_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 添加评论功能这里我用的是韩国的来必力。先打开来必力官网注册。点击现在安装后出现如下页面将红框内的引号内内容复制（==不用复制），打开主题配置文件，定位到livere_uid，将复制内容粘贴上去。 接入百度统计如果没有百度统计账号先注册一个，地址https://tongji.baidu.com/然后在管理页面添加网站，接着在代码管理界面获取代码，会出现如下内容 123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?(你需要复制的内容)"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; 将hm.js?后面的代码复制。打开主题配置文件，定位到baidu_analytics，将刚刚复制下来的内容粘贴到其后面即可。c]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51单片机中断原理及简单应用]]></title>
    <url>%2F2019%2F09%2F02%2F51%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们设想一种状况：有一天你正在看教学♂视频，这时候你老妈突然给你发了条微信“儿砸，干嘛呢”，然后你立马暂停了你的视频，回了句“我，打钱！”。实际上上述过程中就发生了一次中断。 中断的概念上述过程中，你本来在激动地看着视频，但是一条微信打断了这一切，那条消息就叫做中断源。引起CPU中断的根源叫做中断源，中断源向CPU提出申请，CPU暂时中断事件A（教学视频），转而处理事件B（乞讨），对事件B处理完后，再回到原来中断的地方（即断点）（视频暂停的位置）。实现该过程的部件叫做中断系统。 中断嵌套/中断优先级上述过程中，你刚打开微信，准备向你妈乞讨，这时候你同学发来一条消息“上号”，你将选择先打把游戏，再回到微信对你妈说“刚刚在学习没看到”，然后再回到教学视频。同学找你发生在你正准备乞讨时，也就是正在执行中断响应时，那么“上号”就是嵌套的更高级的中断。如果上述两个事件同时发生，你还是会先“上号”，那么就认为“上号”的优先级高于“乞讨”。那么如何确定两个中断哪个优先级更高呢？这取决于中断优先级寄存器的设置，我们再后面会讲到。 中断源51单片机共有5个中断源： INT0：外部中断0，P3.2引脚接入，低电平或下降沿有效； INT1：外部中断1，P3.3接入，低电平或下降沿有效； T0：定时器计数器0中断，由T0计数器计满回零引起； T1：定时器计数器1，T1引起； TI/RI：串行口中断，串行端口完成一帧字符发送/接收后引起。 中断源 中断优先级 中断号 入口地址 INT0 最高 0 0003H T0 第二 1 000BH INT1 第三 2 0013H T1 第四 3 001BH TI/RI 最低 4 0023H 中断允许寄存器中断允许寄存器IE用来设置各中断源的打开与关闭。 中断请求标志TCON控制中断及定时器。 中断系统的结构 上面我们已经介绍了TCON与IE，现在我们来讲一下该结构怎么工作。我们以INT0为例，由上知IT0用来选择外部中断0触发方式，假设我们选择了低电平有效，那当我们遇到低电平，那么进入IE0，当IE0配置为1，即允许中断，在IE寄存器中，EX0也为中断允许控制，当EX0也为1，则进入中断总开关EA，当EA也为1，则进入IP判断优先级，随后执行中断程序。 设置外部中断/编写程序编写程序设计中断一般有以下几个步骤： 设置触发中断方式 设置允许外部中断 允许总中断完成程序后，等待中断发生，机器响应中断并执行服务函数。下面我们编写程序，目标是按下独立按键K3是LED等状态转换1234567891011121314151617181920212223242526272829 #include "reg52.h" //此文件中定义了单片机的一些特殊功能寄存器typedef unsigned int u16; //对数据类型进行声明定义typedef unsigned char u8;sbit k3=P3^2; //定义按键K3sbit led=P2^0; //定义P20口是ledvoid delay(u16 i)&#123; while(i--); &#125;void Int0Init()&#123; //设置INT0 IT0=1;//跳变沿出发方式（下降沿） EX0=1;//打开INT0的中断允许。 EA=1;//打开总中断 &#125;void main()&#123; Int0Init(); // 设置外部中断0 while(1); &#125;void Int0() interrupt 0 //外部中断0的中断函数&#123; delay(1000); //延时消抖 if(k3==0) &#123; led=~led; &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立键盘与矩阵键盘]]></title>
    <url>%2F2019%2F07%2F19%2Fbutton%2F</url>
    <content type="text"><![CDATA[键盘分为编码键盘和非编码键盘。编码键盘上闭合键识别有专用编码器实现，并产生键编码号和键值。非编码键盘靠软件编程来识别，单片机中多为非编码键盘。 独立按键/矩阵按键独立按键独立按键式直接用I/O口线构成的单个按键电路，其特点是每个按键单独占用一根I/O口线，每个按键的工作不会影响其他I/O口线的状态。独立按键查询时，每个端口默认输出高电平，若按键按下，该端口与GND接通，变为低电平，则我们检测哪一个端口为低电平即可确定哪一个按键被按下。 矩阵按键若按键较多，则独立按键方式需要大量I/O口，这这是我们可以用矩阵键盘方式实现。矩阵键盘有四条I/O口做行线，四条I/O口做列线，每个按键都在行列交点上，如下图矩阵键盘检测时，常用行列扫描法：首先我们向控制列线的低四位输入低电压，向控制行线的高四位输高电平。当有按键被按下，该部分电路被导通，低电平通过按键进入高四位，对应的高四位中的I/O口值不再为1。因此我们检测P1端口值，若高四位不全为1，则说明有按键被按下，通过找出哪一个值不为1，可以确定哪一行的按键被按下。接着，再反过来，向高四位输入低电平，低四位输入高电平，检测出被按下的按键在哪一列，就可以得出被按下的按键的坐标。 按键消抖通常按键所用的开关都是机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上就稳定的接通，在断开时也不会一下子彻底断开，而是在闭合和断开的瞬间伴随了一连串的抖动.稳点时间的长短是由操作人员决定的，正常按下一般都在100ms左右，抖动时长由机械结构决定，一般在10ms左右。为了确保按键检测准确，我们应该在按键稳定时检测，所以我们需要消抖。通常消抖有两种方式，硬件消抖和软件消抖。硬件消抖通过在案件两端并联电容的方式稳定电路软件消抖有很多种方式，我这里用最简单的两次停顿来实现。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;reg52.h&gt;#define key P1typedef unsigned int uint;typedef unsigned char uchar;sbit lsa=P2^2;sbit lsb=P2^3;sbit lsc=P2^4;uint num;uchar code smgduan[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00&#125;;uint line,row;void delay(uint i)&#123; while(i--);&#125;void mtrkey()&#123; char a=0; key=0xf0; //高四位为1，低四位为0 if(key!=0xf0)&#123; delay(1000); //第一次停顿，消除前沿抖动 if(key!=0xf0)&#123; key=0Xf0; switch(key) &#123; //找到按键的行 case(0X70): line=0;break; case(0Xb0): line=1;break; case(0Xd0): line=2;break; case(0Xe0): line=3;break; &#125; key=0x0f; //高四位为0，低四位为1 switch(key) &#123; //找到按键的列 case(0X07): row=0;break; case(0X0b): row=1;break; case(0X0d): row=2;break; case(0X0e): row=3;break; &#125; while((key!=0x0f)) //第二次停顿，消除后沿抖动 &#123; delay(1000); key=0x0f; a++; &#125; &#125; &#125;&#125;void main()&#123; lsa=0;lsb=0;lsc=0; P0=smgduan[0]; while(1)&#123; mtrkey(); num=line*4+row; P0=smgduan[num]; &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数码管显示原理及应用实现]]></title>
    <url>%2F2019%2F07%2F18%2F%E4%B8%80%E4%BA%8C%E4%B8%89%E5%9B%9B%E4%BA%94%2F</url>
    <content type="text"><![CDATA[前面学过了发光二极管的控制，再来讲数码管精容易理解了。 静态/动态数码管显示数码管工作原理简介数码管其实就是几个LED灯组合在一起，所以我们操作数码管也就是操作LED灯。图中七个组成数字的LED加一个小数点LED一共八个LED灯管，如果我们要显示1，那就把b和c点亮，其他类推。 共阴极/共阳极接法这八个LED连接的方法有两种，共阴极和共阳极，下图左边是共阴极，右边是共阳极共阴极中，我们给端口输入高电平，LED就会亮共阳极中，我们输入低电平LED亮。 位选/段选如果我们要显示一个8位数，那么我们要控制8个字段，每个字段有8个LED，我们将选定控制哪一位字段的过程叫做位选，将选定控制某一字段中的哪一个LED的过程叫做段选。 静态显示静态显示特点是每一位数码管都要接到一个八位数据线来保存显示字形码。送入字形码后显示的字形可一直保持。比如假设现在我们要显示一个两位数，那么我们可能需要单片机的P1与P2接口，每个接口的8位分别连接两位数码管的八个LED，以此来控制每一位数字的显示。 动态显示静态显示的缺点显然就是占用单片机太多，如果我们需要显示一个8位数，那就需要64个引脚。动态显示将所有数码管段选线并联在一起，有位选线控制是哪一位数码管有效。选亮数码管采用动态扫描显示，轮流向各数码管发送字形码，利用数码管的余辉喝人眼的视觉暂留作用，使人感觉各位数码管在同时显示。 本实验板的电路图这就是HC6800—ES V2.0的数码管的电路。左端的138译码器用来位选，其左上角有ABC三个端口，三端口分别接在P22P23P24引脚上，数值分别是0或1，组成一个三位二进制数，其数值介于0~7之间，用来表示8位数码管。右图左下角是一个573锁存器，在这里的功能是控制某一位上的八个LED灯管，用P0的八位针脚来表示。这样，我们控制单片机的11个引脚，实现了对64个LED的控制。 关于锁存器这块实验板上的锁存器功能体现的不明显，我们以天翔电子的TX-1C为例。那块板子上的段选和位选都是由573锁存器来控制，每个锁存器都有一个锁存端，就是上图中的右图左下角LE端口。当LE打开，锁存器内部导通，上图可以看出锁存器左端接一个个引脚，右端接段选线控制LED，内部导通时引脚输入什么数，右端就会输出 什么数，左端的数会传导到右端。当LE关闭时，内部不导通，左端将保持原来的值不变。 在TX-1C中，我们用两个引脚控制两个锁存器的锁存端，两个锁存器再共用8个引脚做位输入，一共10个引脚完成控制。 位选时，位选锁存器打开，8个引脚输入相应数值（11111110表示控制第一个数码管，11111101表示控制第二个，类推），再关闭锁存器，保存这一数值。接着打开段选的锁存端，输入相应的字形码以控制某一个数码管显示什么数字。 实验程序1234567891011121314151617181920212223242526272829#include&lt;reg52.h&gt; typedef unsigned char uchar;typedef unsigned int uint;sbit lsa=P2^2;sbit lsb=P2^3; sbit lsc=P2^4;uint code smgwei[9][3]=&#123;0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1&#125;; //位选，code将数组存在ROM中uchar code smgduan[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00&#125;; //0,1,2....的字形码void delay(uint i)&#123; while(i--);&#125;void smg(uint i,uint j)&#123; lsa=smgwei[i][2];lsb=smgwei[i][1];lsc=smgwei[i][0]; //位选赋值 P0=smgduan[j]; //断选 delay(100); //因为要以一定的频率刷新，所以需要延时一定时间 P0=0x00; //归零一下，否则在下一位数码管会出现残影&#125;void main()&#123; uint i; while(1)&#123; for(i=0;i&lt;8;i++)&#123; smg(i,i); //第一位到第八位分别显示0~7 &#125; &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蜂鸣器的原理及控制]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%E5%98%80%2F</url>
    <content type="text"><![CDATA[蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于计算机、打印机、复印机、报警器、电子玩具、汽车电子设备、电话机、定时器等电子产品中作发声器件。蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。蜂鸣器在电路中用字母“H”或“HA”（旧标准用“FM”、“ZZG”、“LB”、“JD”等）表示。 蜂鸣器的使用蜂鸣器工作原理有源/无源蜂鸣器先给个百度百科链接有源蜂鸣器，也叫电磁式蜂鸣器，内部有电磁振荡器，接通直流电源后周期性振动发声，无源蜂鸣器，也叫压电式蜂鸣器，内部没有电磁振荡器，需要接带有一定波形的电流，改变波形可以改变发出的声音的音调等等。这块实验板上是一个无源蜂鸣器 实验板上的电路单片机的引脚无法直接驱动蜂鸣器，需要经过信号放大才能驱动。在这块实验板中，蜂鸣器是无源的，用的放大器是ULN2003. 在有源蜂鸣器中，可以直接用一个三极管放大信号，实际上ULN2003内部也是NPN三极管。 程序控制蜂鸣器找引脚接口在上面的电路图中可以看到，蜂鸣器端口标号是 BZ 由于蜂鸣器是接在ULN2003上的，所以在ULN2003电路图上也有一个BZ，与之对应的是端口P15，那么我们控制的就是P15端口。 写程序上面说到了，这块板子上是一个无源蜂鸣器，需要不断变换端口输出值来模拟脉冲信号，引脚参数beep值为1的时候高电平，为0的时候低电平，从1到0变换一次表示一次振动，连续振动就能发声。 #include&lt;reg52.h&gt; typedef unsigned char uchar; typedef unsigned int uint; sbit beep=P1^5; //控制蜂鸣器的引脚为P15 void delay(uint i){ while(i--); } void main(){ while(1){ beep=~beep; delay(80); //每80个单位时间振动一下，周期160单位时间 } }]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点亮发光二极管]]></title>
    <url>%2F2019%2F07%2F10%2F51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[点亮LED，LED闪烁点亮LED第一个内容是关于LED灯的，首先就是如何让他亮。那么我们先看一下这块实验版的LED模块的电路图： （其实图上是有一点错误的，图中的二极管标号从上到下依次是D1 D2 D3….） 图中可以看出，当左端是低电位的时候，二极管导通，LED灯亮。在单片机中，0表示低电位，1表示高电位，所以我们只需要将端口参数置零，LED就会亮。端口参数志玲，端口又是什么呢？我们还是看电路图。我们可以看到，这图里的8个二极管左侧有棕红色的标号P20 P21 P22……这些表示的是处理器的引脚，89C52一共有4组共32个引脚，我们编程控制的就是这些引脚。所以我们将端口置零就是将引脚参数设置为0。在程序中，我们一般这么写： 123456789101112#include&lt;reg52.h&gt; //51单片机的头文件sbit led1=P2^0; //sbit是定义了一个位（一个字节八个位的那个位），和int，float这些差不多sbit led2=P2^1; //这两句话的意思是，定义两个位，名字叫led1，led2，led1存的是引脚p20的值，led2是p21void main()&#123; while(1) //一个死循环，程序才会一直执行下去 &#123; led1=0; //p20引脚参数为0，输出低电平 led2=0; &#125;&#125; 写好后，和C语言类似，我们得先调试，按F7或者点这个调试没有错误以后，我们要将程序拷录进单片机，就要用到 ，具体步骤如下： 上次忘了写一个步骤，就是生成.hex文件，这个在keil里面是默认不生成的，但是拷录时必须是.hex格式的文件。生成步骤如下： 拷录好后，我们再打开单片机，就是这个程序。 LED闪烁到此，我们已经解决了灯亮的问题，如何让灯会闪呢？我们只需要加一个循环，让端口参数从1到0周期变换，就像下面： 123456789101112131415161718#include&lt;reg52.h&gt;typedef unsigned char uc;typedef unsigned int ui;sbit led=P2^0;void delay(ui i)&#123; while(i--);&#125;void main()&#123; while(1)&#123; led=0; delay(10000); led=1; delay(10000); &#125;&#125; 跑马灯只让一个灯闪那不够土，为了够土，我们要让他循环闪。那么最容易想到的就是依次给端口赋值，这样未免太麻烦，我们可以直接这么写 写法1123456789101112131415161718#include&lt;reg52.h&gt;typedef unsigned char uchar;typedef unsigned int uint;void delay(uint i)&#123; //延时函数 while(i--); &#125; void main()&#123; uchar a; a=0x01; while(1)&#123; P2=a; delay(10000); a=a&lt;&lt;1; //位运算，实现循环 if(a==0x00) //防止溢出 a=0x01; &#125; &#125; 0x01是一个十六进制数，表示的是0000 0001，也就是端口P2的值依次为00000001。&lt;&lt; 左移一位后变成了0000 0010。 写法2我们也可以换一种写法，将端口值变为11111110就是0xfe然后循环位变换，这里引进一个函数，_crol_（char，int），效果看程序和结果 1234567891011121314151617#include&lt;reg52.h&gt;#include&lt;intrins.h&gt;typedef unsigned char uchar;typedef unsigned int uint;void delay(uint i)&#123; while(i--);&#125;void main()&#123; uchar a; a=0xfe; //表示1111 1110 while(1)&#123; P2=a; delay(10000); a=_crol_(a,1); //循环位移，函数的第二个参数表示移多少位，这里第一次执行后a变成了1111 1101 &#125;&#125;]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP，洛谷P040]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%A0%91%E5%BD%A2DP%EF%BC%8C%E6%B4%9B%E8%B0%B7P040%2F</url>
    <content type="text"><![CDATA[洛谷P1040/树形DP/区间DP题目描述设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；（1）tree的最高加分（2）tree的前序遍历 输入格式：第1行：一个整数n（n＜30），为节点个数。第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。 输出格式：第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。第2行：n个用空格隔开的整数，为该树的前序遍历。输入输出样例 输入样例：55 7 1 2 10 输出样例：1453 1 2 4 5 题目链接：洛谷P1040 题目解读中序遍历为1，2，3，…..，那么当k为根节点时，编号小于k的节点必然在左子树上，编号大于k的节点必然在右子树上。对于一个节点，当他的值最大时，必然是他左右节点乘积最大时，那么有状态转移方程 f[i][j]=max(f[i][k-1]f[k+1][j])+point[k]，i&lt;=k&lt;=j 遍历每一个节点当作根结点时的情况，再向左子树右子树分别遍历，当f[i][j]有值时直接返回值，没有值时找到最大值并返回（可能不是很好理解，具体见代码）。 同时，每次f[i][j]取得max时，记录root[i][j]，也就是i节点和j节点的根节点，方便输出前序遍历。 更新一个区间DP的写法，思路都是一样的，区间DP先找出两个节点组成树的所有情况，再根据上面的状态转移方程，找出3个节点的情况，最后一步步推出所有节点的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long ans,f[31][31];int n,root[31][31],cot=1;long long dfs(int left,int right) //深搜，树形DP&#123; long long k; if(left&gt;right) return 1; if(f[left][right]==-1) &#123; for(int i=left;i&lt;=right;i++) &#123; k=dfs(left,i-1)*dfs(i+1,right)+f[i][i]; if(k&gt;f[left][right]) &#123; f[left][right]=k; root[left][right]=i; &#125; &#125; &#125; return f[left][right];&#125;void pretra(int left,int right) //输出前序遍历&#123; if(left&gt;right) return; if(cot++!=1) cout&lt;&lt;' '; cout&lt;&lt;root[left][right]; pretra(left,root[left][right]-1); pretra(root[left][right]+1,right); return ;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; f[i][j]=-1; root[i][i]=i; &#125; &#125; for(int i=1;i&lt;=n;i++) cin&gt;&gt;f[i][i]; cout&lt;&lt;dfs(1,n)&lt;&lt;endl; pretra(1,n); return 0;&#125; 区间DP的主要代码： 1234567891011for(int len=2;len&lt;=n;len++)&#123; //最外层枚举长度 for(int i=1;i&lt;=n-len+1;i++)&#123; //第二层，枚举每一个长度为len的片段 int j=i+len-1; for(int k=i;k&lt;=j;k++)&#123; //枚举某一个片段下每个节点当做更节点的情况 if(f[i][j]&lt;f[i][k-1]*f[k+1][j]+f[k][k])&#123; f[i][j]=f[i][k-1]*f[k+1][j]+f[k][k]; root[i][j]=k; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>区间DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何/凸包/安德鲁]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%B0%8F%E5%B8%83%E5%B0%94%E4%B9%94%E4%BA%9A%E2%80%9D%2F</url>
    <content type="text"><![CDATA[计算几何/凸包/安德鲁算法先说一下凸包是啥抽象解释：在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，…Xn)的凸组合来构造（来自百度百科）； 简单理解：对于一个平面空间上的点集，其中的一些点总可以构成一个凸多边形，这个多边形（包括边界）包含了改点集内所有的点，这个凸多边形就是凸包。如图：在计算几何领域，有很多个求凸包的方法，这里主要讲比较容易掌握安德鲁算法（Andrew’s Algorithm)（因为我菜…) 算法基本思路1.将给定的集合的点按X坐标升序排序，X相同则按Y升序排序； 2.创建凸包上部：将排序后的点按从小到大顺序加入凸包A，若新加入的点使凸包A不再是凸多边形，则逆序删除之前加入的点，直到重新变成凸多边形；3.创建凸包下部：将排序后的点按从大到小顺序加入凸包B，若新加入的点使凸包B不再是凸多边形，则逆序删除之前加入的点，直到重新变成凸多边形； （显然排序后的第一个点和最后一个点必定在凸包上）注：若a X b &gt; 0，表示a在b的顺时针方向上若a X b &lt; 0，表示a在b的逆时针方向上若a X b == 0，表示a与b共线，但不确定方向是否相同 下面用图解说明一下安德鲁算法: 第一步，将最开始的两个点加入凸包。第二步，按照顺序选定点Si（不入凸包），若Si在凸包的倒数第二个点和倒数第一个点构成的向量的逆时针方向，就从凸包中删除倒数第一个点，循环此过程，直至Si在该向量顺时针方向，此时将Si入凸包。 点2在点0指向点1的向量的顺时针方向，点2入凸包； 点3在点1指向点2的向量的逆时针方向，点2从凸包中删除，此时点3在点0指向点1的向量的顺时针方向，入凸包；点4在点1指向点3的向量的顺时针方向，点4入凸包；点5在点3指向点4的向量的逆时针方向，点4从凸包中删除，此时点5在点1指向点3的向量的顺时针方向，入凸包；点6在点3指向点5的向量的逆时针方向，点5从凸包中删除，此时点6还在点1指向点3的向量的逆时针方向，点3从凸包中删除，此时点6在点0指向点1的向量的顺时针方向，入凸包；最后点7在点1到点6的向量的顺时针方向，点7入凸包 凸包上部构建完成 下部同理 最后两部分相连，即可得凸包。 代码&amp;例题破oj3348 Cows题目大意：给出一些树的坐标，一这些树为顶点可以围成一片牧场，牧场中每50个单位可以放一头牛，问最多可以放多少牛。求最大牧场面积，就是求凸包面积。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt; using namespace std;struct point&#123; int x,y; point()&#123;&#125; point(int xx,int yy)&#123; x=xx; y=yy; &#125; point operator - (const point a)const&#123; return point(x-a.x,y-a.y); &#125;&#125;p[11000],ch[11000]; //储存原来的点集和凸包序列bool cmp(point a,point b)&#123; //点排序 if(a.x==b.x) return a.y&lt;b.y; return a.x&lt;b.x; &#125;double chachen(point a, point b) &#123; //返回叉乘的膜 return a.x*b.y-a.y*b.x;&#125;int tubao(point *p,int n, point *ch)&#123; //构造凸包 sort(p,p+n,cmp); int m=0; for (int i=0;i&lt;n;i++)&#123; //上部 while (m&gt;1&amp;&amp;chachen(ch[m-1]-ch[m-2],p[i]-ch[m -2])&lt;=0) //删除不凸的点 m--; ch[m++]=p[i]; &#125; int k=m; for (int i=n-2;i&gt;=0;i--)&#123; //下部 while (m&gt;k&amp;&amp;chachen(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) //删除不凸的点 m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m; //返回凸包中元素个数&#125;int main(void)&#123; int n,m,ans; double area = 0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y; m=tubao(p,n,ch); for(int i=0;i&lt;m;i++)&#123; area+=ch[i].x*ch[i+1%m].y-ch[i+1%m].x*ch[i].y;//计算面积 &#125; if(area&lt;=0) area=-area; ans=area/100; //计算面积要除2，再加上计算结果要除50，总共除100 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>安德鲁算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Theme-Sakura]]></title>
    <url>%2F2018%2F12%2F12%2FHexo-Theme-Sakura%2F</url>
    <content type="text"><![CDATA[hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 12345678# Sitetitle: 你的站点名subtitle:description: 站点简介keywords:author: 作者名language: zh-cntimezone: 部署 123456deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） 1234567backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# site name# 站点名 【改】prefixName: さくら荘そのsiteName: hojun# favicon and site master avatar# 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】favicon: /images/favicon.icoavatar: /img/custom/avatar.jpg# 站点url 【改】url: https://sakura.hojun.cn# 站点介绍（或者说是个人签名）【改】description: Live your life with passion! With some drive!# 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpgcdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6# 开启pjax 【选】pjax: 1# 站点首页的公告信息 【改】notice: hexo-Sakura主题已经开源，目前正在开发中...# 懒加载的加载中图片 【选】lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg# 站点菜单配置 【选】menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125;# Home page sort type: -1: newer first，1: older first. 【非】homePageSortType: -1# Home page article shown number) 【非】homeArticleShown: 10# 背景图片 【选】bgn: 8# startdash面板 url, title, desc img 【改】startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125;# your site build time or founded date# 你的站点建立日期 【改】siteBuildingTime: 07/17/2018# 社交按钮(social) url, img PC端配置 【改】social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125;# 社交按钮(msocial) url, img 移动端配置 【改】msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125;# 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg# 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true# Valine评论配置【改】valine: truev_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHszv_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 12345678910111213141516171819#category# 按分类名创建技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg#tag# 标签名即是标题悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： 123456789---title: commentdate: 2018-12-20 23:13:48keywords: 留言板description: comments: true# 在这里配置单页面头部图片，自定义替换哦~photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg--- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） 123456789101112131415161718192021222324252627282930---layout: bangumititle: bangumicomments: falsedate: 2019-02-10 21:32:48keywords:description:bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。--- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） 1234567891011121314151617181920212223242526272829303132333435363738394041424344---layout: linkstitle: links# 创建日期，可以改下date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改keywords: 友人帐 description: # true/false 开启/关闭评论comments: true # 页面头部图片，自定义修改photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像--- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： 1&#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： 1&#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
</search>
